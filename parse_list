#!/usr/bin/env bash

set -o errexit
set -o errtrace
set -o nounset
set -o pipefail

declare __dir
__dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly __dir

declare __file
__file="${__dir}/$(basename "${BASH_SOURCE[0]}")"
readonly __file

declare __base
__base="$(basename "${__file}" .sh)"
readonly __base

# shellcheck source=./lib/env.sh
source "$__dir"/lib/env.sh

# shellcheck source=./lib/log.sh
source "$__dir"/lib/log.sh

# shellcheck source=./lib/exit_codes.sh
source "$__dir"/lib/exit_codes.sh

declare output_flag=false
declare force_overwrite=false
declare input_flag=false
declare format_flag=false
  
declare input_file=""
declare output_file=""
declare format=""

declare -a dates=()
declare -a countries=()
declare -a places=()
declare -a names=()
declare -a nationalities=()
declare -a ages=()
declare -a notes=()

usage() {
  cat << MSG
Parses the HTML from scrape_list into a more usable format.

Usage:
  ${__base} [options]

OPTIONS
  -i, --input <FILE>
      The file to read the HTML from. If not specified, reads from STDIN.
  -o, --output <FILE>
      Specifies the file to write the results to. If not specified, writes to STDOUT instead. If the file exists, you will be asked to confirm overwriting it.
  -f, --force
      Overwrites the output file without prompting.
  -F, --format <sql|json|csv>
      The format to generate. Defaults to sql inserts for sqlite3.
  -h, --help
      Prints this message.
MSG
}

prompt_input_or_output() {
  local file="$1"
  echo "Both input and output file flags were specified."
  echo "$file"
  read -r -n 1 -p "Please specify whether the above file is [i]nput or [o]utput." res
  case ${res:0:1} in
    I|i)
      input_file="$file"
    ;;
    O|o)
      output_file="$file"
    ;;
    *)
      printf "\n"
      err $EX_FILE_AMBIGUITY "Unable to determine if input or output file: $file"
    ;;
  esac
}

process_args() {
  while [[ $# -gt 0 ]]; do
	  if [[ $1 =~ ^- ]]; then
		  # Convert combined short options into multiples short options (e.g. '-qb' to '-q -b')
		  if [[ $1 =~ ^-[a-z]{2,} ]]; then
			  param=$1
			  shift
			  set -- "${param:0:2}" "-${param:2}" "$@"
			  unset param
		  fi
		  case $1 in
			  -h | --help)  
                usage
                exit 0  
              ;;
			  -f | --force) 
                force_overwrite=true
              ;;
			  -o | --output)
			    output_flag=true
			  ;;
			  -i | --input)
			    input_flag=true
              ;;
              -F | --format)
                format_flag=true
              ;;
			  *)
                err $EX_UNKNOWN_OPT "Unknown option '$1'"
              ;;
		  esac
		  shift
	  else
	    local arg="$1"
	    
	    if [[ "$format_flag" == true && -z "$format" ]]; then
          case "$arg" in
            sql|json|csv)
              format="$arg"
              shift
              continue
            ;;
          esac  
        fi
        
        [[ "$input_flag" == true && -z "$input_file" ]] && needs_input_file=true || needs_input_file=false
        [[ "$output_flag" == true && -z "$output_file" ]] && needs_output_file=true || needs_output_file=false
        if [[ "$needs_input_file" == true && "$needs_output_file" == true ]]; then
          prompt_input_or_output "$arg"    
        elif [[ "$needs_output_file" == true ]]; then
          output_file="$arg"
        elif [[ "$needs_input_file" == true ]]; then
          input_file="$arg"
        else
          err $EX_UNKNOWN_OPT "Unknown option '$1'"
        fi
        shift
	  fi
  done
}

check_overwrite() {
  if [[ -e "$output_file" ]]; then
    if [[ -d "$output_file" ]]; then
      err $EX_OUTPUT_FILE_DIRECTORY "Directory was specified as output file."
    fi
    
    if [[ "$force_overwrite" != true ]]; then
      read -r -n 1 -p "Output file ($output_file) already exists. Overwrite? (y/n)? " res
      case ${res:0:1} in
        y|Y) ;; # no op; we fail if it's not yes.
        *)
          printf "\n"
          err $EX_OUTPUT_FILE_EXISTS_NO_OW "$output_file already exists. Use the -f flag to force overwriting an existing file."
        ;;
      esac
    fi
  fi
}

validate_arguments() {
  # some sanity checks
  if [[ -z "$output_file" ]]; then
    if [[ "$output_flag" == true ]]; then
      err $EX_MISSING_OUTPUT_FILE "Output file option given but no file specified."
    fi
    
    if [[ "$force_overwrite" == true ]]; then
      err $EX_FORCE_NO_OUTPUT "Force option given but no output file specified."
    fi
  fi
  
  check_overwrite
  
  if [[ -z "$input_file" && "$input_flag" == true ]]; then
      err $EX_MISSING_INPUT_FILE "Input file option given but no file specified."
  fi
  
  if [[ -n "$input_file" ]]; then
    if [[ ! -e "$input_file" ]]; then
      err $EX_INPUT_FILE_NOT_FOUND "The specified input file does not exist ($input_file)"
    fi
    
    if [[ -d "$input_file" ]]; then
      err $EX_INPUT_FILE_DIRECTORY "Directory was specified as input file ($input_file)."
    fi
  fi
}

validate_env() {
  local missing=""
  exists "pup" || missing+=$'\tpup: an HTML parser\n'
  exists "jq" ||  missing+=$'\tjq:  a JSON parser\n'
  
  if [[ -n "$missing" ]]; then
    err $EX_MISSING_CMD $'Please ensure you have installed the following program(s):\n'"$missing"
  fi
}

read_html() {
  cat "${input_file:-/dev/stdin}"
}

count_columns() {
  pup "tr:nth-of-type(1)" <<< "$1" | grep --count "<th>"
}

initialize_column_map() {
  local -n __map="$1"
  local -ri columns="$2"
  
  local -i ages_col=6
  local -i notes_col=7
  
  if [ "$columns" -gt 7 ]; then
    ((++ages_col))
    ((++notes_col))
  fi
  readonly ages_col
  readonly notes_col
  
  # This isn't directly referenced, but
  # it's used via nameref.
  # shellcheck disable=2034
  __map=(
    ["dates"]=1
    ["countries"]=2
    ["places"]=3
    ["names"]=4
    ["nationalities"]=5
    ["ages"]="$ages_col"
    ["notes"]="$notes_col"
  )
}

column_cells() {
  local -n __arrays="$1"
  local -r table="$2"
  
  for a in "${!__arrays[@]}"; do
    local -n __array="$a"
    
    local -i column="${__arrays[$a]}"
    
    local cells_str
    cells_str=$(pup --charset utf-8 "td:nth-child($column)" <<< "$table")
    local -i i=0
    
    while read -r line; do
      __array[i]="${__array[i]:-}${line}"$'\n'
      if [ "$line" == "</td>" ]; then
        ((++i))
      fi
    done <<< "$cells_str"
  done
}

main() {
  validate_env

  process_args "$@"

  validate_arguments

  local html
  html=$(read_html)
  readonly html
  
  local table
  table=$(pup 'table.wikitable' <<< "$html")
  readonly table
  
  local -i column_count
  column_count=$(count_columns "$table")
  readonly column_count
  
  local -A column_map=()
  initialize_column_map column_map "$column_count"
  
  echo "${#column_map[@]}"
  
  column_cells column_map "$table"
}

main "$@"